# Plan: Comprehensive CLI Support for Viro

## Executive Summary

**Problem**: Viro currently has minimal CLI support - only REPL mode with basic flags (`--sandbox-root`, `--allow-insecure-tls`). There is no way to:
- Execute script files directly
- Evaluate expressions from command line
- Configure REPL behavior (prompts, history, output)
- Control tracing/debugging from startup
- Set global interpreter options
- Use Viro in shell pipelines or automation

**Solution**: Implement comprehensive CLI interface supporting:
1. Multiple execution modes (REPL, script file, eval expression, check syntax)
2. Rich configuration flags for all subsystems
3. Standard I/O integration for Unix pipeline compatibility
4. Environment variable support for configuration
5. Version/help information
6. Exit codes following Unix conventions

**Impact**: Transform Viro from REPL-only tool to full-featured interpreter suitable for:
- Automation scripts (cron, CI/CD)
- Shell pipelines and filters
- Configuration processing
- Data transformation workflows
- Interactive development (enhanced REPL)

## Current State Analysis

### Existing CLI Implementation

**File**: `cmd/viro/main.go`
```go
var (
    sandboxRoot      = flag.String("sandbox-root", "", "...")
    allowInsecureTLS = flag.Bool("allow-insecure-tls", false, "...")
)

func main() {
    flag.Parse()
    // Resolve sandbox root
    // Always starts REPL
    repl.Run()
}
```

**Limitations**:
- Only REPL mode available
- No script file execution
- No version/help commands
- No output/error configuration
- No trace/debug startup control
- No check/validate mode
- Cannot use in shell pipelines

### Existing Infrastructure

**Strengths**:
- REPL with readline support (`internal/repl/repl.go`)
- Parser can handle file input (`internal/parse/parse.go`)
- Evaluator decoupled from REPL (`internal/eval/evaluator.go`)
- Trace system ready (`internal/trace/trace.go`)
- Debug system ready (`internal/debug/debug.go`)
- Structured error system (`internal/verror/error.go`)

**Gaps**:
- No file execution mode
- No expression evaluation mode
- No syntax check mode
- No configuration management
- No proper exit codes

## Proposed Architecture

### Execution Modes

```
viro [global-flags] <mode> [mode-flags] [arguments]

Modes:
  (none)           Interactive REPL (default)
  <file>           Execute script file
  -c <expr>        Evaluate expression
  --check <file>   Syntax check only
  --version        Show version
  --help           Show help
```

### Flag Categories

**1. Global Flags** (apply to all modes)
```
--sandbox-root <path>        Sandbox root for file I/O (default: cwd)
--allow-insecure-tls         Disable TLS certificate verification
--trace-file <path>          Trace output file (default: stderr)
--trace-max-size <MB>        Max trace file size before rotation
--quiet                      Suppress non-error output
--verbose                    Enable verbose output
--color <auto|always|never>  Colorize output (default: auto)
```

**2. REPL Flags** (REPL mode only)
```
--no-history                 Disable command history
--history-file <path>        History file location
--prompt <string>            Custom primary prompt
--no-welcome                 Skip welcome message
--trace-on                   Start with tracing enabled
--debug-on                   Start with debugger enabled
```

**3. Script Flags** (script execution mode)
```
--args <...>                 Arguments passed to script (REBOL-style)
--check-only                 Parse and validate, don't execute
--show-parse                 Display parsed AST
--profile                    Show execution profile
```

**4. Eval Flags** (-c mode)
```
--stdin                      Read additional input from stdin
--no-print                   Don't print result (like echo -n)
```

### Directory Structure

```
cmd/viro/
├── main.go           # Entry point, mode dispatch
├── repl.go           # REPL mode (wrapper - exists)
├── script.go         # Script execution mode (NEW)
├── eval.go           # Expression evaluation mode (NEW)
├── check.go          # Syntax check mode (NEW)
├── config.go         # Configuration management (NEW)
├── version.go        # Version info (NEW)
└── help.go           # Help text (NEW)
```

### Configuration Priority

1. **Command-line flags** (highest priority)
2. **Environment variables** (`VIRO_*`)
3. **Config file** (`~/.virorc` or `$VIRO_CONFIG`)
4. **Built-in defaults** (lowest priority)

Example environment variables:
```bash
VIRO_SANDBOX_ROOT=/workspace
VIRO_HISTORY_FILE=~/.viro_history  # Already supported
VIRO_TRACE_FILE=~/.viro/trace.log
VIRO_COLOR=always
VIRO_PROMPT="viro> "
```

### Exit Codes

Following Unix conventions:
```
0   Success
1   General error (Script error, Math error, etc.)
2   Syntax error (Parse failure)
3   Access error (Permission denied, sandbox violation)
64  Usage error (Invalid CLI arguments)
70  Internal error (Interpreter crash)
130 Interrupted (Ctrl+C)
```

## Implementation Plan

### Phase 1: Core Infrastructure (Week 1)

**Goal**: Establish configuration system and mode dispatch framework

#### T1.1: Configuration System
- Create `cmd/viro/config.go`
- Define `Config` struct with all settings
- Implement environment variable loading
- Implement config file parsing (simple key=value)
- Implement priority merging (flags > env > file > defaults)
- Add validation for all config values

**Files**: `cmd/viro/config.go`
**Tests**: `cmd/viro/config_test.go`
**Estimated**: 2 days

#### T1.2: Version and Help
- Create `cmd/viro/version.go` with version constants
- Create `cmd/viro/help.go` with comprehensive help text
- Add `--version` flag and handler
- Add `--help` flag with mode-specific help
- Extract version from build tags or embed

**Files**: `cmd/viro/version.go`, `cmd/viro/help.go`
**Tests**: `cmd/viro/help_test.go`
**Estimated**: 1 day

#### T1.3: Mode Dispatch
- Refactor `cmd/viro/main.go` to dispatch modes
- Detect mode from arguments (file path vs flags)
- Validate flags per mode (REPL flags invalid in script mode)
- Set up proper signal handling (SIGINT, SIGTERM)
- Map errors to exit codes

**Files**: `cmd/viro/main.go`
**Tests**: `cmd/viro/main_test.go`
**Estimated**: 2 days

**Deliverable**: `viro --version`, `viro --help` work; mode detection in place

---

### Phase 2: Script Execution Mode (Week 2)

**Goal**: Enable `viro script.viro` and `viro --check script.viro`

#### T2.1: File Loading
- Create `cmd/viro/script.go`
- Implement file reading with error handling
- Support reading from stdin (`viro -` or `viro /dev/stdin`)
- Handle missing files with proper error messages
- Respect sandbox-root for relative paths

**Files**: `cmd/viro/script.go`
**Tests**: `cmd/viro/script_test.go`
**Estimated**: 1 day

#### T2.2: Script Execution
- Parse script contents using `parse.Parse()`
- Initialize evaluator with script-specific settings
- Execute parsed values using `evaluator.DoBlock()`
- Handle errors with proper exit codes
- Support `--args` passing to script (via special word like `system/args`)

**Files**: `cmd/viro/script.go`
**Tests**: `test/integration/script_exec_test.go`
**Estimated**: 2 days

#### T2.3: Syntax Check Mode
- Create `cmd/viro/check.go`
- Implement `--check <file>` mode
- Parse only (no evaluation)
- Report syntax errors with line/column
- Exit 0 on valid syntax, 2 on errors
- Optional: `--show-parse` to display AST

**Files**: `cmd/viro/check.go`
**Tests**: `cmd/viro/check_test.go`
**Estimated**: 1 day

#### T2.4: Integration Tests
- Create test scripts in `test/scripts/`
- Test successful execution
- Test syntax errors in scripts
- Test runtime errors in scripts
- Test argument passing
- Test stdin input

**Files**: `test/integration/script_test.go`, `test/scripts/*.viro`
**Tests**: Full integration suite
**Estimated**: 1 day

**Deliverable**: `viro test.viro` executes scripts; `viro --check test.viro` validates syntax

---

### Phase 3: Expression Evaluation Mode (Week 3)

**Goal**: Enable `viro -c "expr"` for command-line evaluation

#### T3.1: Eval Mode Implementation
- Create `cmd/viro/eval.go`
- Handle `-c` or `--eval` flag with expression argument
- Parse expression from command line
- Execute and print result
- Support `--no-print` to suppress output
- Handle multiline expressions (quoted strings)

**Files**: `cmd/viro/eval.go`
**Tests**: `cmd/viro/eval_test.go`
**Estimated**: 1 day

#### T3.2: Stdin Integration
- Support `--stdin` flag to read additional input
- Combine command-line expression with stdin data
- Enable pipeline usage: `echo "[1 2 3]" | viro -c "first"`
- Handle EOF gracefully
- Support binary input for data processing

**Files**: `cmd/viro/eval.go`
**Tests**: `test/integration/eval_stdin_test.go`
**Estimated**: 2 days

#### T3.3: Output Formatting
- Respect `--quiet` flag (suppress results)
- Implement `--color` flag for syntax highlighting
- Format output for terminal vs pipe (detect TTY)
- Support `--format <mold|form|json>` for different outputs
- Handle large results (pagination or truncation)

**Files**: `cmd/viro/eval.go`, `internal/format/` (NEW)
**Tests**: `cmd/viro/eval_format_test.go`
**Estimated**: 2 days

**Deliverable**: `viro -c "3 + 4"` prints `7`; pipeline support works

---

### Phase 4: Enhanced REPL Configuration (Week 4)

**Goal**: Make REPL behavior fully configurable via CLI/config

#### T4.1: REPL Configuration
- Add REPL-specific flags to config system
- Pass config to `repl.NewREPL()` via options
- Support `--prompt`, `--no-welcome`, `--no-history`
- Support `--trace-on`, `--debug-on` startup modes
- Allow REPL customization via `~/.virorc`

**Files**: `internal/repl/repl.go`, `cmd/viro/repl.go`
**Tests**: `internal/repl/repl_config_test.go`
**Estimated**: 2 days

#### T4.2: REPL Environment
- Set environment variables from config
- Expose config to REPL via `system/config` object
- Allow runtime config changes (e.g., `set-prompt ">>> "`)
- Persist config changes to file (optional `save-config`)

**Files**: `internal/repl/repl.go`, `internal/native/system.go` (NEW)
**Tests**: `test/integration/repl_env_test.go`
**Estimated**: 2 days

#### T4.3: Output Control
- Implement `--color` with auto-detection (isatty)
- Add syntax highlighting to REPL output
- Support `--quiet` mode (suppress welcome, prompts minimal)
- Add `--verbose` with execution timing/stats

**Files**: `internal/repl/repl.go`, `internal/format/color.go` (NEW)
**Tests**: `internal/repl/repl_output_test.go`
**Estimated**: 1 day

**Deliverable**: Fully configurable REPL with custom prompts, colors, startup behavior

---

### Phase 5: Advanced Features (Week 5)

**Goal**: Add profiling, debugging integration, and power-user features

#### T5.1: Profiling Support
- Add `--profile` flag for script mode
- Collect execution statistics (function calls, time)
- Display profile report after execution
- Support `--profile-output <file>` for analysis tools
- Integrate with trace system for detailed events

**Files**: `cmd/viro/script.go`, `internal/profile/` (NEW)
**Tests**: `test/integration/profile_test.go`
**Estimated**: 2 days

#### T5.2: Debug/Trace Integration
- Support `--trace-on` to start with tracing enabled
- Support `--debug-on` to start with debugger active
- Allow `--breakpoint <file:line>` from CLI
- Enable stepping through scripts from start
- Support `--trace-filter <pattern>` to reduce noise

**Files**: `cmd/viro/main.go`, `internal/trace/trace.go`, `internal/debug/debug.go`
**Tests**: `test/integration/debug_cli_test.go`
**Estimated**: 2 days

#### T5.3: Script Arguments
- Implement `system/args` block with script arguments
- Support `--args` separator: `viro script.viro --args arg1 arg2`
- Parse arguments as Viro values (not just strings)
- Support `--` to end flag parsing: `viro script.viro -- --not-a-flag`

**Files**: `cmd/viro/script.go`, `internal/native/system.go` (NEW)
**Tests**: `test/integration/script_args_test.go`
**Estimated**: 1 day

**Deliverable**: Production-ready CLI with profiling, debugging, argument passing

---

### Phase 6: Documentation and Polish (Week 6)

**Goal**: Complete documentation, examples, and edge case handling

#### T6.1: Comprehensive Help
- Write detailed `--help` output for each mode
- Create man page (`docs/viro.1`)
- Add examples to help text
- Document all flags with defaults
- Create troubleshooting section

**Files**: `cmd/viro/help.go`, `docs/viro.1`
**Tests**: Manual verification
**Estimated**: 2 days

#### T6.2: Examples and Recipes
- Create `examples/` directory with sample scripts
- Add CLI cookbook (`docs/cli-cookbook.md`)
- Show pipeline examples
- Show automation examples (cron, CI/CD)
- Show debugging workflow examples

**Files**: `examples/*.viro`, `docs/cli-cookbook.md`
**Tests**: Integration tests from examples
**Estimated**: 2 days

#### T6.3: Error Message Refinement
- Improve error messages for common mistakes
- Add suggestions for flag typos (`--helo` → did you mean `--help`?)
- Better error context for file not found
- Clear messages for invalid combinations
- Test error messages with users

**Files**: `cmd/viro/*.go`
**Tests**: `test/integration/error_messages_test.go`
**Estimated**: 1 day

#### T6.4: Edge Cases and Hardening
- Test with extremely long command lines
- Test with binary input/output
- Test with non-UTF8 input
- Test with broken pipes (SIGPIPE)
- Test with all signal interruptions
- Memory leak testing for long-running scripts

**Files**: All `cmd/viro/*.go`
**Tests**: `test/integration/edge_cases_test.go`
**Estimated**: 2 days

**Deliverable**: Production-quality CLI with comprehensive docs and robust error handling

---

## Implementation Details

### Code Structure

#### `cmd/viro/config.go`

```go
package main

type Config struct {
    // Global
    SandboxRoot      string
    AllowInsecureTLS bool
    TraceFile        string
    TraceMaxSize     int
    Quiet            bool
    Verbose          bool
    Color            ColorMode
    
    // REPL-specific
    NoHistory        bool
    HistoryFile      string
    Prompt           string
    NoWelcome        bool
    TraceOn          bool
    DebugOn          bool
    
    // Script-specific
    Args             []string
    CheckOnly        bool
    ShowParse        bool
    Profile          bool
    
    // Eval-specific
    Stdin            bool
    NoPrint          bool
    Format           string
}

type ColorMode int

const (
    ColorAuto ColorMode = iota
    ColorAlways
    ColorNever
)

func LoadConfig() (*Config, error)
func (c *Config) Validate() error
func (c *Config) MergeFlags(flags *flag.FlagSet) error
```

#### `cmd/viro/main.go`

```go
package main

import (
    "flag"
    "fmt"
    "os"
)

type Mode int

const (
    ModeREPL Mode = iota
    ModeScript
    ModeEval
    ModeCheck
    ModeVersion
    ModeHelp
)

func main() {
    config, err := LoadConfig()
    if err != nil {
        fmt.Fprintf(os.Stderr, "Configuration error: %v\n", err)
        os.Exit(ExitUsage)
    }
    
    mode := detectMode(config, flag.Args())
    
    var exitCode int
    switch mode {
    case ModeREPL:
        exitCode = runREPL(config)
    case ModeScript:
        exitCode = runScript(config, flag.Arg(0))
    case ModeEval:
        exitCode = runEval(config)
    case ModeCheck:
        exitCode = runCheck(config)
    case ModeVersion:
        printVersion()
        exitCode = ExitSuccess
    case ModeHelp:
        printHelp(config)
        exitCode = ExitSuccess
    }
    
    os.Exit(exitCode)
}

func detectMode(cfg *Config, args []string) Mode {
    if cfg.Version {
        return ModeVersion
    }
    if cfg.Help {
        return ModeHelp
    }
    if cfg.Eval != "" {
        return ModeEval
    }
    if cfg.CheckOnly {
        return ModeCheck
    }
    if len(args) > 0 {
        return ModeScript
    }
    return ModeREPL
}
```

#### `cmd/viro/script.go`

```go
package main

import (
    "fmt"
    "os"
    
    "github.com/marcin-radoszewski/viro/internal/eval"
    "github.com/marcin-radoszewski/viro/internal/parse"
    "github.com/marcin-radoszewski/viro/internal/verror"
)

func runScript(cfg *Config, scriptPath string) int {
    content, err := loadScript(cfg, scriptPath)
    if err != nil {
        fmt.Fprintf(os.Stderr, "Error loading script: %v\n", err)
        return ExitError
    }
    
    values, err := parse.Parse(content)
    if err != nil {
        printParseError(err)
        return ExitSyntax
    }
    
    if cfg.ShowParse {
        printAST(values)
    }
    
    if cfg.CheckOnly {
        return ExitSuccess
    }
    
    evaluator := setupEvaluator(cfg)
    injectScriptArgs(evaluator, cfg.Args)
    
    _, err = evaluator.DoBlock(values)
    if err != nil {
        return handleError(err)
    }
    
    return ExitSuccess
}

func loadScript(cfg *Config, path string) (string, error) {
    if path == "-" {
        return readStdin()
    }
    
    fullPath := resolvePath(cfg.SandboxRoot, path)
    return os.ReadFile(fullPath)
}
```

#### `cmd/viro/eval.go`

```go
package main

import (
    "fmt"
    "io"
    "os"
    
    "github.com/marcin-radoszewski/viro/internal/eval"
    "github.com/marcin-radoszewski/viro/internal/parse"
    "github.com/marcin-radoszewski/viro/internal/native"
)

func runEval(cfg *Config) int {
    expr := cfg.EvalExpr
    
    if cfg.Stdin {
        stdinData, err := io.ReadAll(os.Stdin)
        if err != nil {
            fmt.Fprintf(os.Stderr, "Error reading stdin: %v\n", err)
            return ExitError
        }
        expr = string(stdinData) + "\n" + expr
    }
    
    values, err := parse.Parse(expr)
    if err != nil {
        printParseError(err)
        return ExitSyntax
    }
    
    evaluator := setupEvaluator(cfg)
    result, err := evaluator.DoBlock(values)
    if err != nil {
        return handleError(err)
    }
    
    if !cfg.NoPrint && !cfg.Quiet {
        formatted := formatResult(result, cfg)
        fmt.Println(formatted)
    }
    
    return ExitSuccess
}

func formatResult(val core.Value, cfg *Config) string {
    switch cfg.Format {
    case "mold":
        return val.Mold()
    case "form":
        return val.Form()
    case "json":
        return toJSON(val)
    default:
        return val.Form()
    }
}
```

### Exit Codes (`cmd/viro/exit.go`)

```go
package main

const (
    ExitSuccess  = 0   // Successful execution
    ExitError    = 1   // General error
    ExitSyntax   = 2   // Parse/syntax error
    ExitAccess   = 3   // Access/permission error
    ExitUsage    = 64  // Invalid usage
    ExitInternal = 70  // Internal error
    ExitInterrupt = 130 // SIGINT
)

func handleError(err error) int {
    if vErr, ok := err.(*verror.Error); ok {
        printViroError(vErr)
        return categoryToExitCode(vErr.Category)
    }
    
    fmt.Fprintf(os.Stderr, "Error: %v\n", err)
    return ExitError
}

func categoryToExitCode(cat verror.Category) int {
    switch cat {
    case verror.CategorySyntax:
        return ExitSyntax
    case verror.CategoryAccess:
        return ExitAccess
    case verror.CategoryInternal:
        return ExitInternal
    default:
        return ExitError
    }
}
```

## Testing Strategy

### Unit Tests

- **Config system**: Test flag parsing, env variables, priority merging
- **Mode detection**: Test all mode combinations
- **File loading**: Test paths, stdin, missing files
- **Error handling**: Test all exit codes
- **Formatting**: Test output modes (mold/form/json)

### Integration Tests

Create `test/integration/cli_test.go`:

```go
func TestCLIScriptExecution(t *testing.T) {
    tests := []struct {
        name       string
        script     string
        args       []string
        wantExit   int
        wantStdout string
    }{
        {
            name:       "simple expression",
            script:     "print 42",
            wantExit:   0,
            wantStdout: "42\n",
        },
        {
            name:       "syntax error",
            script:     "print [unclosed",
            wantExit:   2,
            wantStdout: "",
        },
        {
            name:       "runtime error",
            script:     "1 / 0",
            wantExit:   1,
            wantStdout: "",
        },
    }
    
    for _, tt := range tests {
        t.Run(tt.name, func(t *testing.T) {
            // Create temp script
            // Run viro
            // Check exit code and output
        })
    }
}
```

### End-to-End Tests

Create actual `.viro` scripts in `test/scripts/`:

```viro
; test/scripts/hello.viro
print "Hello, World!"
```

Run with:
```bash
./viro test/scripts/hello.viro
viro --check test/scripts/hello.viro
viro -c 'print "inline"'
echo "[1 2 3]" | viro -c "first --stdin"
```

### Manual Testing Checklist

- [ ] `viro` starts REPL
- [ ] `viro script.viro` executes script
- [ ] `viro -c "expr"` evaluates expression
- [ ] `viro --check script.viro` validates syntax
- [ ] `viro --version` shows version
- [ ] `viro --help` shows help
- [ ] Exit codes correct for all error types
- [ ] Ctrl+C handled gracefully
- [ ] Pipe usage works: `echo "..." | viro -c "..."`
- [ ] Config file respected
- [ ] Environment variables work
- [ ] All flags work in appropriate modes

## Dependencies

**No new Go dependencies required** - use stdlib only:
- `flag` for argument parsing
- `os` for file/env operations
- `io` for stdin/stdout
- `fmt` for formatting

**Optional future enhancements** (not in initial plan):
- `github.com/spf13/cobra` - Better CLI framework (if stdlib becomes limiting)
- `github.com/fatih/color` - Better color support (if needed)
- `github.com/mitchellh/go-homedir` - Cross-platform home dir (if needed)

## Documentation Requirements

### User Documentation

1. **CLI Reference** (`docs/cli-reference.md`)
   - All flags explained
   - All modes with examples
   - Exit codes documented
   - Environment variables listed

2. **Cookbook** (`docs/cli-cookbook.md`)
   - Common use cases
   - Pipeline examples
   - Automation examples
   - Integration with other tools

3. **Man Page** (`docs/viro.1`)
   - Standard Unix man page format
   - Installable via `man viro`

### Developer Documentation

1. **Update CLAUDE.md**
   - Add CLI commands section
   - Document mode detection
   - Explain config system

2. **Architecture Doc** (`docs/cli-architecture.md`)
   - Design rationale
   - Mode dispatch flow
   - Config priority system
   - Extension points

## Migration Path

### Backward Compatibility

**Existing behavior preserved**:
- `./viro` still starts REPL (no breaking change)
- Existing flags (`--sandbox-root`, `--allow-insecure-tls`) work unchanged
- REPL history location unchanged (`~/.viro_history`)

**New defaults safe**:
- Color: auto-detect (no forced colors)
- Config file: optional (not required)
- All new flags have sensible defaults

### Deprecation (if any)

No deprecations in Phase 1. Future consideration:
- Deprecate bare flags in favor of subcommands (e.g., `viro repl`, `viro run script.viro`)
- This would be Phase 7+ after user feedback

## Success Criteria

### Functional Requirements

- ✅ Execute `.viro` script files
- ✅ Evaluate expressions from command line
- ✅ Check syntax without execution
- ✅ Pass arguments to scripts
- ✅ Use in Unix pipelines
- ✅ Configure via flags/env/file
- ✅ Proper exit codes
- ✅ Comprehensive help

### Non-Functional Requirements

- ✅ No performance regression (REPL startup <100ms)
- ✅ Memory efficient (no leaks in long scripts)
- ✅ Backward compatible (existing usage works)
- ✅ Well documented (--help, man page, examples)
- ✅ Test coverage >80% for new code
- ✅ Cross-platform (Linux, macOS, Windows)

### User Acceptance

- ✅ REBOL users feel at home
- ✅ Unix users find it familiar
- ✅ Automation use cases enabled
- ✅ No surprising behavior
- ✅ Clear error messages

## Timeline

**Total**: 6 weeks (30 working days)

| Phase | Duration | Deliverable |
|-------|----------|-------------|
| Phase 1: Core Infrastructure | Week 1 (5 days) | Config system, version/help, mode dispatch |
| Phase 2: Script Execution | Week 2 (5 days) | File execution, syntax check |
| Phase 3: Expression Eval | Week 3 (5 days) | CLI eval, stdin integration, formatting |
| Phase 4: REPL Enhancement | Week 4 (5 days) | Configurable REPL, environment |
| Phase 5: Advanced Features | Week 5 (5 days) | Profiling, debug integration, arguments |
| Phase 6: Documentation | Week 6 (5 days) | Help, examples, hardening |

**Milestones**:
- End of Week 2: Script execution working
- End of Week 4: Core CLI complete and usable
- End of Week 6: Production-ready with docs

## Risks and Mitigations

| Risk | Impact | Mitigation |
|------|--------|------------|
| Config system complexity | High | Use simple key=value format, not TOML/YAML |
| Flag parsing edge cases | Medium | Comprehensive tests, follow POSIX conventions |
| Cross-platform issues | Medium | Test on Linux/macOS/Windows, use stdlib only |
| Backward compatibility breaks | High | Extensive testing, gradual rollout |
| Performance regression | Medium | Benchmark REPL startup, profile scripts |

## Future Enhancements (Not in Scope)

- **Subcommands**: `viro run`, `viro check`, `viro fmt`
- **Package manager**: `viro install package`
- **REPL history search**: Ctrl+R for history
- **Tab completion**: Bash/Zsh completion scripts
- **LSP support**: Language server protocol
- **Hot reload**: Watch mode for development
- **Remote execution**: Execute on remote Viro instances

## References

- REBOL CLI: http://www.rebol.com/docs/core23/rebolcore-10.html
- Red CLI: https://github.com/red/red/wiki/Command-Line-Interface
- Go flag package: https://pkg.go.dev/flag
- Unix exit codes: https://www.freebsd.org/cgi/man.cgi?query=sysexits

## Appendix: Example Usage

### Script Execution
```bash
# Execute script
viro hello.viro

# With arguments
viro process.viro --args data.txt output.txt

# From stdin
cat input.viro | viro -

# Check syntax
viro --check potentially-broken.viro
```

### Expression Evaluation
```bash
# Simple expression
viro -c "3 + 4 * 2"  # Prints: 14

# With stdin
echo "[1 2 3 4 5]" | viro -c "first"  # Prints: 1

# No output (use in scripts)
result=$(viro -c "pow 2 10" --no-print)

# JSON output
viro -c "[name: "Alice" age: 30]" --format json
```

### REPL Customization
```bash
# Custom prompt
viro --prompt "λ "

# No welcome message
viro --no-welcome

# Start with tracing
viro --trace-on

# Custom history location
viro --history-file ~/my-viro-history
```

### Automation Examples
```bash
# Cron job
0 * * * * /usr/local/bin/viro /scripts/hourly-report.viro

# CI/CD pipeline
viro --check *.viro && viro run-tests.viro

# Shell pipeline
cat data.csv | viro -c "parse-csv | filter-records | to-json"

# Pre-commit hook
#!/bin/bash
viro --check $1 || exit 1
```

---

**Status**: Draft (Ready for Review)
**Author**: Claude Code
**Date**: 2025-10-23
