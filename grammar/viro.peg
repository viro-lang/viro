{
package peg

import (
    "encoding/hex"
    "fmt"
    "strconv"
    "strings"
    "unicode"
    "github.com/ericlagergren/decimal"
    "github.com/marcin-radoszewski/viro/internal/core"
    "github.com/marcin-radoszewski/viro/internal/value"
)

func toInt(s string) int64 {
    n, _ := strconv.ParseInt(s, 10, 64)
    return n
}

func toDecimal(s string) (*decimal.Big, int16) {
    d := new(decimal.Big)
    d.SetString(s)
    scale := calculateScale(s)
    return d, scale
}

func calculateScale(s string) int16 {
    if idx := strings.Index(s, "."); idx >= 0 {
        endIdx := len(s)
        if eIdx := strings.IndexAny(s, "eE"); eIdx > idx {
            endIdx = eIdx
        }
        return int16(endIdx - idx - 1)
    }
    return 0
}

func buildPath(segments []value.PathSegment, isSet bool) core.Value {
    if isSet {
        pathStr := ""
        for i, seg := range segments {
            if i > 0 {
                pathStr += "."
            }
            switch seg.Type {
            case value.PathSegmentWord:
                pathStr += seg.Value.(string)
            case value.PathSegmentIndex:
                pathStr += fmt.Sprintf("%d", seg.Value.(int64))
            }
        }
        return value.NewSetWordVal(pathStr)
    }
    path := value.NewPath(segments, value.NewNoneVal())
    return value.PathVal(path)
}

func toSlice(v any) []any {
    if v == nil { return nil }
    return v.([]any)
}

func flattenValues(v any) []core.Value {
	if v == nil {
		return []core.Value{}
	}
	slice := toSlice(v)
	result := make([]core.Value, 0, len(slice))
	for _, item := range slice {
		if val, ok := item.(core.Value); ok {
			result = append(result, val)
		}
	}
	return result
}

func parseHex(hexStr string) ([]byte, error) {
	cleaned := strings.Map(func(r rune) rune {
		if unicode.IsSpace(r) {
			return -1
		}
		return r
	}, hexStr)
	
	if cleaned == "" {
		return []byte{}, nil
	}
	
	if len(cleaned) % 2 != 0 {
		return nil, fmt.Errorf("binary literal requires even number of hex digits")
	}
	
	bytes, err := hex.DecodeString(cleaned)
	if err != nil {
		return nil, fmt.Errorf("invalid hex character in binary literal")
	}
	
	return bytes, nil
}
}

Input <- _ vals:Value* _ EOF {
    return flattenValues(vals), nil
}

Value <- _ val:(Decimal / Integer / Binary / String / Block / Paren /
                Path / SetPath / SetWord / GetPath / GetWord / LitWord /
                Datatype / Word) _ {
	return val, nil
}

Integer <- '-'? [0-9]+ !DecimalStart {
    return value.NewIntVal(toInt(string(c.text))), nil
}

DecimalStart <- [.eE]

Decimal <- '-'? [0-9]+ '.' [0-9]+ ([eE] [+-]? [0-9]+)? !'.' {
    d, scale := toDecimal(string(c.text))
    return value.DecimalVal(d, scale), nil
} / '-'? [0-9]+ [eE] [+-]? [0-9]+ {
    d, scale := toDecimal(string(c.text))
    return value.DecimalVal(d, scale), nil
}

String <- '"' [^"]* '"' {
	text := string(c.text)
	content := text[1:len(text)-1]
	return value.NewStrVal(content), nil
}

Binary <- '#' '{' content:HexContent '}' {
	hexStr := string(content.([]byte))
	bytes, err := parseHex(hexStr)
	if err != nil {
		return nil, err
	}
	return value.NewBinaryVal(bytes), nil
}

HexContent <- [0-9A-Fa-f \t\n\r]* {
	return c.text, nil
}

HexDigit <- [0-9A-Fa-f]

SetWord <- word:WordChars ':' !':' {
    wordStr := word.(string)
    if strings.Contains(wordStr, ".") {
        return nil, fmt.Errorf("set-word cannot contain dots")
    }
    return value.NewSetWordVal(wordStr), nil
}

GetPath <- ':' first:WordChars rest:('.' PathElement)+ {
    segments := make([]value.PathSegment, 0)
    segments = append(segments, value.PathSegment{
        Type: value.PathSegmentWord,
        Value: first.(string),
    })

    for _, item := range toSlice(rest) {
        parts := toSlice(item)
        segment := parts[1]

        var segStr string
        switch v := segment.(type) {
        case string:
            segStr = v
        case []byte:
            segStr = string(v)
        default:
            segStr = ""
        }

        if num, err := strconv.ParseInt(segStr, 10, 64); err == nil {
            segments = append(segments, value.PathSegment{
                Type: value.PathSegmentIndex,
                Value: num,
            })
        } else {
            segments = append(segments, value.PathSegment{
                Type: value.PathSegmentWord,
                Value: segStr,
            })
        }
    }

    path := value.NewGetPath(segments, value.NewNoneVal())
    return value.GetPathVal(path), nil
}

SetPath <- first:WordChars rest:('.' PathElement)+ ':' {
    segments := make([]value.PathSegment, 0)
    segments = append(segments, value.PathSegment{
        Type: value.PathSegmentWord,
        Value: first.(string),
    })

    for _, item := range toSlice(rest) {
        parts := toSlice(item)
        segment := parts[1]

        var segStr string
        switch v := segment.(type) {
        case string:
            segStr = v
        case []byte:
            segStr = string(v)
        default:
            segStr = ""
        }

        if num, err := strconv.ParseInt(segStr, 10, 64); err == nil {
            segments = append(segments, value.PathSegment{
                Type: value.PathSegmentIndex,
                Value: num,
            })
        } else {
            segments = append(segments, value.PathSegment{
                Type: value.PathSegmentWord,
                Value: segStr,
            })
        }
    }

    path := value.NewSetPath(segments, value.NewNoneVal())
    return value.SetPathVal(path), nil
}

GetWord <- ':' word:WordChars {
    return value.NewGetWordVal(word.(string)), nil
}

LitWord <- '\'' word:WordChars {
    return value.NewLitWordVal(word.(string)), nil
}

Path <- first:WordChars rest:('.' PathElement)+ !':' {
    segments := make([]value.PathSegment, 0)
    segments = append(segments, value.PathSegment{
        Type: value.PathSegmentWord,
        Value: first.(string),
    })
    
    for _, item := range toSlice(rest) {
        parts := toSlice(item)
        segment := parts[1]
        
        var segStr string
        switch v := segment.(type) {
        case string:
            segStr = v
        case []byte:
            segStr = string(v)
        default:
            segStr = ""
        }
        
        if num, err := strconv.ParseInt(segStr, 10, 64); err == nil {
            segments = append(segments, value.PathSegment{
                Type: value.PathSegmentIndex,
                Value: num,
            })
        } else {
            segments = append(segments, value.PathSegment{
                Type: value.PathSegmentWord,
                Value: segStr,
            })
        }
    }
    
    path := value.NewPath(segments, value.NewNoneVal())
    return value.PathVal(path), nil
}

PathElement <- WordChars / [0-9]+ {
    return string(c.text), nil
}

Word <- word:WordChars {
    return value.NewWordVal(word.(string)), nil
}

WordChars <- [\p{L}_?+*/<>=-] [\p{L}\p{N}_?+*/<>=-]* {
    return string(c.text), nil
}

SimpleWordChars <- [\p{L}_?+*/<>=-] [\p{L}\p{N}_?+*/<>=-]* {
    return string(c.text), nil
}

Block <- '[' _ vals:Value* _ ']' {
    return value.NewBlockVal(flattenValues(vals)), nil
}

Paren <- '(' _ vals:Value* _ ')' {
    return value.NewParenVal(flattenValues(vals)), nil
}

Datatype <- word:WordChars '!' {
    return value.NewDatatypeVal(word.(string) + "!"), nil
}

_ <- ([ \t\n\r] / Comment)*

Comment <- ';' [^\n]* '\n'?

EOF <- !.
